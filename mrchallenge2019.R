#####################################################################################################################
# mrchallenge2019.R
# Description: for experimenting with running EM algorithm on datasets 
#####################################################################################################################

##### Set directory
setwd("~/Dropbox/MR_Bayes/MRChallenge2019")

# load libraries 
library(MRChallenge2019)
library(Rcpp)
library(RcppArmadillo)
library(RcppDist)
library(mclust)
library(mr.raps)
library(MASS)
library(dplyr)
library(ggplot2)

##### Load EM algorithm and related functions 
sourceCpp("../MC-EM/EM.cpp")

#####################################################################################################################
# Code for running MC-EM algorithm with data from MR Data Challenge 2019
#####################################################################################################################

# HDLc_data <- read.table("../Data/Summary_statistics_MAGNETIC_M.HDL.C.txt.gz", header = TRUE)
# 
# # subset strong instruments, filter out NAs
# # use GLGC for selecting SNPs, NMR data as exposure
# strongInstr_dat <- Challenge_dat %>% filter(p_hdl < 5e-8) %>% filter(complete.cases(.))
# strongInstr_SNPs <- strongInstr_dat$rsid
# # exposure
# beta.exposure <- as.numeric(as.character(HDLc_data$beta[HDLc_data$ID %in% strongInstr_SNPs]))
# se.exposure <- as.numeric(as.character(HDLc_data$se[HDLc_data$ID %in% strongInstr_SNPs]))
# pval.exposure <-as.numeric(as.character(HDLc_data$p.value[HDLc_data$ID %in% strongInstr_SNPs]))
# hdl_amd_data <- data.frame(SNP = strongInstr_SNPs, beta.exposure, se.exposure, pval.exposure,
#                            beta.outcome = strongInstr_dat[,"beta_amd"], se.outcome = strongInstr_dat[,"se_amd"], 
#                            pval.selection = strongInstr_dat[,"p_hdl"])
# save(hdl_amd_data, file = "hdl_amd_data.RData")

# load("hdl_amd_data.RData")
# 
# mr.raps_res <- mr.raps(data = hdl_amd_data)
# 
# k <- 1
# modal.plot(data = hdl_amd_data, k = k)
# 
# mr.raps.scatterplot(data = hdl_amd_data, FALSE, num.snps = nrow(hdl_amd_data))
# 
# 
# X <- hdl_amd_data[,"beta.exposure"]
# seX <- hdl_amd_data[,"se.exposure"] 
# Y <- hdl_amd_data[,"beta.outcome"] 
# seY <- hdl_amd_data[,"se.outcome"] 
# 
# # # plot histograms
# # par(mfrow = c(2,2))
# # hist(X)
# # hist(seX)
# # hist(Y)
# # hist(seY)
# # par(mfrow = c(1,1))
# # ratio <- Y / X
# # std_ratio <- (seX / seY)*(Y / X)
# # par(mfrow = c(1,2))
# # hist(ratio, breaks = 15)
# # # hist(std_ratio, breaks = 25)
# # modal.plot(data = data, k = 1)
# # par(mfrow = c(1,1))
# 
# ####################### MC-EM Algorithm ###############################
# 
# sourceCpp("../EM2/Rcpp/EM.cpp")
# 
# # set initial values 
# K <- 2
# init_m_X <- mean(X)
# init_lambdaX <- sd(X)
# initPis <- rep(1/K, K)
# initMus <- c(-2, 2)
# initSds <- rep(0.4,K)
# initTau <- 1
# initVals <- list("pis" = initPis, "mus" = initMus, "sds" = initSds, 
#                  "m_X" = init_m_X, "lambdaX" = init_lambdaX, "tau" = initTau)
# 
# # set algorithm parameters
# M <- 5 # determines rate at which MC sample size increases with each iteration
# max_Nsamples <- 1e6 # max. MC sample size 
# max_iters <- 100 # max. number of iterations 
# Nstart_MC <- 300 # starting MC sample size 
# eps <- 1e-2 # threshold for determining convergence 
# alpha <- 0.10
# gamma <- 0.10
# invGammaPrior <-FALSE
# prior_shape <- 1
# prior_scale <- (0.10)^2 * (prior_shape + 1)
# verbose <- TRUE
# equalSds <- FALSE
# overDispersedY <- TRUE
# 
# MCEM_fit <- MR_EM(K, initVals, Nstart_MC, X, Y, 
#                   seX, seY, overDispersedY = overDispersedY, equalSds = equalSds, invGammaPrior = invGammaPrior, prior_shape = prior_shape,
#                   prior_scale = prior_scale, M = M, max_Nsamples = max_Nsamples, max_iters = max_iters, 
#                   eps=eps, verbose = verbose)
# 
# 
# mr.raps_scatter <- mr.raps.scatterplot(hdl_amd_data, FALSE, num.snps = nrow(hdl_amd_data))
# mr.raps_scatter + geom_abline(intercept = 0, slope = MCEM_fit$mus, color = "blue")



#################################################################################################
# Code for running MC-EM algorithm using data generated by Qingyuan (data_for_daniel3.rda)
#################################################################################################

# load data 
load("RDS-files/data_for_daniel3.rda")

data <- combined.data[, c("SNP", "pval_ldl_teslovich",
                          "beta_ldl_c_kettunen", "se_ldl_c_kettunen",
                          "beta_amd_ukbb", "se_amd_ukbb")]
names(data) <- c("SNP", "pval.selection",
                 "beta.exposure", "se.exposure",
                 "beta.outcome", "se.outcome")
data <- subset(data, pval.selection < 1e-4)

##### Run mr.raps
mr.raps(data = data)

##### Plot modal plot and scatterplot
modal.plot(data = data, k = 1.5)
mr.raps.scatterplot(data, FALSE, num.snps = nrow(data))

X <- data[,"beta.exposure"]
Y <- data[,"beta.outcome"]
seX <- data[,"se.exposure"]
seY <- data[,"se.outcome"]

###### set initial values
K <- 2
init_m_X <- mean(X)
init_lambdaX <- sd(X)
initPis <- rep(1/K, K)
initMus <- c(-0.02,0.02)
initSds <- rep(0.20,K)
initTau <- 1
initVals <- list("pis" = initPis, "mus" = initMus, "sds" = initSds,
                 "m_X" = init_m_X, "lambdaX" = init_lambdaX, "tau" = initTau)

###### set algorithm parameters
M <- 5 # determines rate at which MC sample size increases with each iteration
max_Nsamples <- 1e6 # max. MC sample size
max_iters <- 100 # max. number of iterations
Nstart_MC <- 300 # starting MC sample size
eps <- 1e-2 # threshold for determining convergence
alpha <- 0.10
gamma <- 0.10
prior_shape <- 1
prior_scale <- (0.10)^2 * (prior_shape + 1)

invGammaPrior <-FALSE
equalSds <- FALSE
overDispersedY <- FALSE
verbose <- TRUE

##### Run algorithm
MCEM_fit <- MR_EM(K, initVals, Nstart_MC, X, Y,
                  seX, seY, overDispersedY = overDispersedY, equalSds = equalSds, invGammaPrior = invGammaPrior, prior_shape = prior_shape,
                  prior_scale = prior_scale, M = M, max_Nsamples = max_Nsamples, max_iters = max_iters,
                  eps=eps, verbose = verbose)

##### Plot scatterplot with fits from algorithm
mr.raps_scatter <- mr.raps.scatterplot(data, FALSE, num.snps = nrow(data))
mr.raps_scatter + geom_abline(intercept = 0, slope = MCEM_fit$mus, color = "blue")

##### Sample from posterior P(\beta_i, \mu_Xi, Z_i | Xi, Yi, parameter estimates)
post_impt_samps <- sampleLatentVarPost(50000, X, Y, seX, seY, MCEM_fit)
W <- post_impt_samps$W # importance sampling weights
rowSumW <- rowSums(W) 
muX_samps <- post_impt_samps$muX_samps
beta_samps <- post_impt_samps$beta_samps
alpha_samps <- post_impt_samps$alpha_samps

##### Estimates of P(Z_i = k | Xi, Yi, parameter estimates)
prob_est <- matrix(NA, nrow = nrow(data), ncol = K)
for (k in 1:K) {
  prob_est[,k] <- rowSums(W * alpha_samps[,,k]) / rowSumW
}

##### Estimates of E(\beta_i | Xi, Yi, parameter estimates)
beta_est <- rowSums(W * post_impt_samps$beta_samps) / rowSumW
# plot histogram
hist(beta_est, breaks = 30) 

###################### Fisher combination test ################################
# fisher.combo_test <- function(pval_vec) {
#   ts <- -2 * sum(log(pval_vec)) 
#   return(1 - pchisq(ts, df = 2*length(pval_vec)))
# }
# fisher_pval_vec <- c()
# for (colname in colnames(combined.data)[seq(39,492, by = 3)]) {
#   fisher_pval_vec <- c(fisher_pval_vec, fisher.combo_test(data.pos_beta[[colname]]))
# }
# names(fisher_pval_vec) <- colnames(combined.data)[seq(39,492, by = 3)]
# fisher.combo_test(data.pos_beta$pval_m_ldl_c_kettunen)

############################### p-value heatmap ###########################################
library(gplots)

pval.mtx <- combined.data[,colnames(combined.data)[seq(39,492, by = 3)]]
rownames(pval.mtx) <- combined.data$SNP

# colnames(pval.mtx) <-
#   sapply(colnames(pval.mtx), function(s) {a <- strsplit(s, "_")[[1]];
#   paste(a[c(-1,-length(a))], collapse = "_")})
pval.mtx2 <- log(data.matrix(pval.mtx[data$SNP[order(beta_est)],]), 10)
save(pval.mtx2, file = "pval.mtx2.RData")
quantile(pval.mtx2, c(.01,.99))
pmax(pval.mtx2, -10)
heatmap.2(pmax(pval.mtx2, -10),
          dendrogram = "none", Rowv = FALSE, Colv = FALSE,trace='none',key=TRUE)
dev.off()

heatmap.2(pmax(pval.mtx2,-24), Rowv=NULL,Colv=NULL, 
          col = rev(rainbow(20*10, start = 0/6, end = 4/6)), 
          scale="none",
          margins=c(3,0), # ("margin.Y", "margin.X")
          trace='none', 
          symkey=FALSE, 
          symbreaks=FALSE, 
          dendrogram='none',
          density.info='none', 
          denscol="black",
          keysize=0.25, "left.margin",
          #( "bottom.margin", "left.margin", "top.margin", "left.margin" )
          key.par=list(mar=c(3.5,0,3,0)),
          # lmat -- added 2 lattice sections (5 and 6) for padding
          lmat=rbind(c(5, 4, 2), c(6, 1, 3)), lhei=c(2.5, 5), lwid=c(1, 10, 1))


